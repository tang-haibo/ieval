<h3 style='line-height: 40px;'>
  <span>ieval is Remote code loading tool</span>
  <a href="https://github.com/tang-haibo/remote-import/actions/workflows/deploy.yml/badge.svg">
    <img src="https://github.com/tang-haibo/remote-import/actions/workflows/deploy.yml/badge.svg" alt="Build Status">
  </a>
  <a href='https://coveralls.io/github/tang-haibo/remote-import?branch=master'>
    <img src='https://coveralls.io/repos/github/tang-haibo/remote-import/badge.svg?branch=master' alt='Coverage Status' />
  </a>
  <a href='https://www.npmjs.com/package/ieval'>
    <img src='https://img.shields.io/npm/v/ieval' alt='ieval version'>
  </a>
</h3>
<p align='center'>
  <b>English</b>
  |
  <a href='README.zh.md'>中文文档</a>
</p>

### What can it do?
* Reduce the size of your wechat mini program
* Help you convert your static audit code to dynamically executed code, implementing dynamic eval on projects without an eval environment
* When you implement the 'document' 'window' context object in an environment that does not support a browser, we can use it for low-code, multi-platform dynamic load execution

### How does it work?
* I tried to implement dynamic code execution through the syntax tree of @babel/parser
* But 'ieval' needs to specify the context of the implementation, because each individual environment should be maintained by the business itself, otherwise it will greatly increase our maintenance costs
### What are its advantages?
* In contrast to EVAL5 and CanJS, which are executed based on "Acorn" code, although "@babel/ Parser" is also based on it, But parts of the code are actually incompatible, so 'ieval' can be run entirely directly with code compiled by Babel, or directly with AST code generated by '@babel/ Parser'
* We implemented complete unit tests, including switch if break operator function var return ...

### Documentation
#### install
```javascript
npm install ieval
```
#### DocumentEval Class
``` javascript
import {DocumentEval} from 'ieval';

// To set the URL request, 'ieval' needs to return a complete executable code string via 'Promise'
DocumentEval.setNetwork(url => {
  return new Promise(resolve => {
    wx.request({
      url: url,
      success: data => {
        resolve(data.data);
      },
    })
  });
});

// This environment variable is especially important because it is needed for system objects that we depend on in our JS code, such as window global document
// If the code currently executing does not need the system object we can leave it blank to avoid security issues during execution
const context = {};

const ieval = new DocumentEval(context);

// Insert your URL connection in the context
ieval.appendUrl('https://image.xxx.com/echarts.js');
ieval.appendUrl('https://image.xxx.com/vue.js');

// We then use 'getWindow' to get the global variable declared in the code we execute
const ctx = await ieval.getWindow();

// run.
ctx.echarts.init();
```

#### iEval Function
``` javascript
import {iEval} from 'ieval';
// We then use 'getWindow' to get the global variable declared in the code we execute
// If the code currently executing does not need the system object we can leave it blank to avoid security issues during execution
const context = {};
// Insert your URL connection in the context
const ieval = iEval(['console.log("start.")', 'https://image.xxx.com/echarts.js', 'https://image.xxx.com/vue.js','console.log("end.")'], context);

const ctx = await ieval.getWindow();

// run.
ctx.echarts.init();
```

##### In this way we have implemented a basic resource load execution

### Matters needing attention
* It is important to include appropriate context objects in the current environment. If the current environment does not have system objects in use, we can set it to {}.